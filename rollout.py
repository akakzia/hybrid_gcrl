import numpy as np


class RolloutWorker:
    def __init__(self, env, policy, goal_sampler, args):

        self.env = env
        self.policy = policy
        self.env_params = args.env_params
        self.goal_sampler = goal_sampler
        self.args = args

    def generate_rollout(self, goals, external, true_eval, bootstrapping=False, animated=False):
        # If bootstrapping, it doesn't matter what goals are used
        # We consider as if they were external to let them be generated by the simulator
        external = external or bootstrapping
        episodes = []

        for i in range(len(goals)):
            external = True if goals[i] is None else False
            observation = self.env.unwrapped.reset_goal(goal=np.array(goals[i]), external=external)
            obs = observation['observation']
            ag = observation['achieved_goal']
            g = observation['desired_goal']

            ep_obs, ep_ag, ep_g, ep_actions, ep_success, ep_rewards = [], [], [], [], [], [],

            # Start to collect samples
            for t in range(self.env_params['max_timesteps']):
                # Run policy for one step
                no_noise = true_eval  # do not use exploration noise if running self-evaluations or offline evaluations
                
                # In bootstrapping phase, perform random action to discover some goals
                if bootstrapping:
                    action = self.env.unwrapped.action_space.sample()
                else:
                    action = self.policy.act(obs.copy(), ag.copy(), g.copy(), no_noise)

                # feed the actions into the environment
                if animated:
                    self.env.render()

                observation_new, r, _, info = self.env.step(action)
                obs_new = observation_new['observation']
                ag_new = observation_new['achieved_goal']
                success = info['is_success']

                # Append rollouts
                ep_obs.append(obs.copy())
                ep_ag.append(ag.copy())
                ep_g.append(g.copy())
                ep_actions.append(action.copy())
                ep_rewards.append(r)
                ep_success.append(success)

                # Re-assign the observation
                obs = obs_new
                ag = ag_new

            ep_obs.append(obs.copy())
            ep_ag.append(ag.copy())

            # Gather everything
            episode = dict(obs=np.array(ep_obs).copy(),
                           act=np.array(ep_actions).copy(),
                           g=np.array(ep_g).copy(),
                           ag=np.array(ep_ag).copy(),
                           success=np.array(ep_success).copy(),
                           rewards=np.array(ep_rewards).copy())

            episodes.append(episode)

        return episodes

